{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Aneesah\\\\Desktop\\\\fs0422-epistaurant-pt5-main\\\\src\\\\components\\\\ReservationList.jsx\",\n  _s = $RefreshSig$();\n// this will be a component capable of fetching live data in its mounting process\n// for understanding this, we have to focus once again on the connection\n// we have to establish between the interface of the component and its state (its logic)\n\n// STEPS HAPPENING:\n// 1) INITIAL RENDER() INVOKATION: this will output to the page the static parts,\n// like the <h2> tag or the shell for the empyty ListGroup (empty since the state\n// is still empty at this moment, [])\n// 2) because we wrote a componentDidMount, that is what happens next, since\n// COMPONENTDIDMOUNT FIRES AFTER THE INITIAL RENDER() INVOKATION;\n// componentDidMount fetches the data (it's perfect for doing expensive operations),\n// and sets the state just once (you're guaranteed of that)\n// 3) because a setState just happened in the componentDidMount, RENDER() (who\n// is always listening for state changes) detects it and FIRES AGAIN! will now\n// leave in place the static parts, since there's no need to rewrite them, but\n// when it's time to map the array for generating the list, since now we have\n// filled our state with reservations, will generate the new elements of the list.\n\nimport { ListGroup, Spinner, Alert, Container, Row, Col } from \"react-bootstrap\";\nimport { parseISO, format } from \"date-fns\";\nimport { useEffect, useState } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ReservationList = () => {\n  _s();\n  // very common situation: you want to fill the interface of a component\n  // at load time, and show the user the results of your fetch\n\n  // every time you need to fetch data upon component loading, you need\n  // a place to store it! you'll use the COMPONENT STATE for this!\n\n  // state = {\n  //   reservations: [],\n  //   isLoading: true,\n  //   isError: false,\n  // }\n\n  const [reservations, setReservations] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isError, setIsError] = useState(false);\n  const fetchReservations = async () => {\n    try {\n      let response = await fetch(\"https://striveschool-api.herokuapp.com/api/reservation\");\n      if (response.ok) {\n        // everything looks ok :)\n        let data = await response.json();\n        // console.log(data)\n        // data is the array of reservations we're getting back from the API\n        // this.setState({\n        //   reservations: data,\n        //   isLoading: false,\n        // })\n        setReservations(data);\n        setIsLoading(false);\n      } else {\n        console.log(\"error fetching the reservations :(\");\n        // server reached, but it encountered a problem with our request\n        setTimeout(() => {\n          // this.setState({\n          //   isLoading: false,\n          //   isError: true,\n          // })\n          setIsLoading(false);\n          setIsError(true);\n        }, 1000);\n      }\n    } catch (error) {\n      console.log(error);\n      // this error happens when you're not able at all to reach the server...\n      // (internet problem?)\n      // this.setState({\n      //   isLoading: false,\n      //   isError: true,\n      // })\n      setIsLoading(false);\n      setIsError(true);\n    }\n  };\n\n  // componentDidMount() {\n  //   console.log('COMPONENTDIDMOUNT FIRED!')\n  //   // componentDidMount is another lifecycle method, but it's guaranteed\n  //   // to be executed JUST ONCE :)\n  //   // it is designed to launch fetches, expensive operations to fill your\n  //   // initial state with dynamic data, and never being called again.\n  //   // ONE-SHOT METHOD.\n  //   this.fetchReservations()\n\n  //   // COMPONENT DID MOUNT HAPPENS AFTER INITIAL RENDER() INVOKATION!\n  // }\n\n  useEffect(() => {\n    console.log(\"COMPONENTDIDMOUNT FIRED!\");\n    fetchReservations();\n  }, [\n    // we're leaving this empty since there's no need to listen to any other\n    // variable change in order to repeat the execution of the callback!\n  ]);\n\n  // just a test method, if launched from render() crashes the application\n  // since setting the state calls render() again --> INFINITE LOOP\n  //   thisWillCrash = () => {\n  //     this.setState({\n  //       reservations: [],\n  //     })\n  //   }\n\n  // render() is a lifecycle method!\n  // render() is in charge of outputting the JSX from the component\n  // render() is invoked when the component mounts, and it's invoked AGAIN\n  // every time there's a change in the STATE of the component or the PROPS\n  // the component is receiving\n  // this.fetchReservations()\n  // PLEASE, DON'T SET YOUR STATE FROM RENDER()!\n  // this.thisWillCrash()\n\n  console.log(\"RENDER FIRED!\");\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(Container, {\n      children: /*#__PURE__*/_jsxDEV(Row, {\n        children: /*#__PURE__*/_jsxDEV(Col, {\n          children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n            children: \"RESERVATIONS LIST\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 128,\n            columnNumber: 13\n          }, this), isLoading && /*#__PURE__*/_jsxDEV(Spinner, {\n            animation: \"border\",\n            role: \"status\",\n            className: \"custom-spinner-color\",\n            children: /*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"sr-only\",\n              children: \"Loading...\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 140,\n              columnNumber: 17\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 135,\n            columnNumber: 15\n          }, this)\n          //   JSX IS ALWAYS A TRUTHY VALUE, SO WHAT YOU'RE REALLY CHECKING\n          // IS THE TRUTHINESS OF YOUR CONDITION\n          , /*#__PURE__*/_jsxDEV(ListGroup, {\n            className: \"mt-4\",\n            children: [reservations.map(r => /*#__PURE__*/_jsxDEV(ListGroup.Item, {\n              children: [r.name, \" for \", r.numberOfPeople, \" |\", \" \", format(parseISO(r.dateTime), \"MMMM do yyyy - HH:mm\")]\n            }, r._id, true, {\n              fileName: _jsxFileName,\n              lineNumber: 151,\n              columnNumber: 17\n            }, this)\n            // we'd like to convert r.dateTime, which is an ugly timestamp,\n            // to a proper formatted date. We're going to use 2 methods from date-fns:\n            // 1) parseISO takes the ugly timestamp and creates a Date object for it,\n            // pointing to a moment in time\n            // 2) format instead takes a Date object, and returns a string in the\n            // format you like\n            ), isError && /*#__PURE__*/_jsxDEV(Alert, {\n              variant: \"danger\",\n              children: \"Whoopsie, something went wrong! :(\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 163,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 145,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 127,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 126,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 125,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 124,\n    columnNumber: 5\n  }, this);\n};\n_s(ReservationList, \"Fh1S27LtBde2rCaQfteL8Tfd1xw=\");\n_c = ReservationList;\nexport default ReservationList;\nvar _c;\n$RefreshReg$(_c, \"ReservationList\");","map":{"version":3,"names":["ListGroup","Spinner","Alert","Container","Row","Col","parseISO","format","useEffect","useState","ReservationList","reservations","setReservations","isLoading","setIsLoading","isError","setIsError","fetchReservations","response","fetch","ok","data","json","console","log","setTimeout","error","map","r","name","numberOfPeople","dateTime","_id"],"sources":["C:/Users/Aneesah/Desktop/fs0422-epistaurant-pt5-main/src/components/ReservationList.jsx"],"sourcesContent":["// this will be a component capable of fetching live data in its mounting process\r\n// for understanding this, we have to focus once again on the connection\r\n// we have to establish between the interface of the component and its state (its logic)\r\n\r\n// STEPS HAPPENING:\r\n// 1) INITIAL RENDER() INVOKATION: this will output to the page the static parts,\r\n// like the <h2> tag or the shell for the empyty ListGroup (empty since the state\r\n// is still empty at this moment, [])\r\n// 2) because we wrote a componentDidMount, that is what happens next, since\r\n// COMPONENTDIDMOUNT FIRES AFTER THE INITIAL RENDER() INVOKATION;\r\n// componentDidMount fetches the data (it's perfect for doing expensive operations),\r\n// and sets the state just once (you're guaranteed of that)\r\n// 3) because a setState just happened in the componentDidMount, RENDER() (who\r\n// is always listening for state changes) detects it and FIRES AGAIN! will now\r\n// leave in place the static parts, since there's no need to rewrite them, but\r\n// when it's time to map the array for generating the list, since now we have\r\n// filled our state with reservations, will generate the new elements of the list.\r\n\r\nimport { ListGroup, Spinner, Alert, Container, Row, Col } from \"react-bootstrap\"\r\nimport { parseISO, format } from \"date-fns\"\r\nimport { useEffect, useState } from \"react\"\r\n\r\nconst ReservationList = () => {\r\n  // very common situation: you want to fill the interface of a component\r\n  // at load time, and show the user the results of your fetch\r\n\r\n  // every time you need to fetch data upon component loading, you need\r\n  // a place to store it! you'll use the COMPONENT STATE for this!\r\n\r\n  // state = {\r\n  //   reservations: [],\r\n  //   isLoading: true,\r\n  //   isError: false,\r\n  // }\r\n\r\n  const [reservations, setReservations] = useState([])\r\n  const [isLoading, setIsLoading] = useState(true)\r\n  const [isError, setIsError] = useState(false)\r\n\r\n  const fetchReservations = async () => {\r\n    try {\r\n      let response = await fetch(\r\n        \"https://striveschool-api.herokuapp.com/api/reservation\"\r\n      )\r\n      if (response.ok) {\r\n        // everything looks ok :)\r\n        let data = await response.json()\r\n        // console.log(data)\r\n        // data is the array of reservations we're getting back from the API\r\n        // this.setState({\r\n        //   reservations: data,\r\n        //   isLoading: false,\r\n        // })\r\n        setReservations(data)\r\n        setIsLoading(false)\r\n      } else {\r\n        console.log(\"error fetching the reservations :(\")\r\n        // server reached, but it encountered a problem with our request\r\n        setTimeout(() => {\r\n          // this.setState({\r\n          //   isLoading: false,\r\n          //   isError: true,\r\n          // })\r\n          setIsLoading(false)\r\n          setIsError(true)\r\n        }, 1000)\r\n      }\r\n    } catch (error) {\r\n      console.log(error)\r\n      // this error happens when you're not able at all to reach the server...\r\n      // (internet problem?)\r\n      // this.setState({\r\n      //   isLoading: false,\r\n      //   isError: true,\r\n      // })\r\n      setIsLoading(false)\r\n      setIsError(true)\r\n    }\r\n  }\r\n\r\n  // componentDidMount() {\r\n  //   console.log('COMPONENTDIDMOUNT FIRED!')\r\n  //   // componentDidMount is another lifecycle method, but it's guaranteed\r\n  //   // to be executed JUST ONCE :)\r\n  //   // it is designed to launch fetches, expensive operations to fill your\r\n  //   // initial state with dynamic data, and never being called again.\r\n  //   // ONE-SHOT METHOD.\r\n  //   this.fetchReservations()\r\n\r\n  //   // COMPONENT DID MOUNT HAPPENS AFTER INITIAL RENDER() INVOKATION!\r\n  // }\r\n\r\n  useEffect(\r\n    () => {\r\n      console.log(\"COMPONENTDIDMOUNT FIRED!\")\r\n      fetchReservations()\r\n    },\r\n    [\r\n      // we're leaving this empty since there's no need to listen to any other\r\n      // variable change in order to repeat the execution of the callback!\r\n    ]\r\n  )\r\n\r\n  // just a test method, if launched from render() crashes the application\r\n  // since setting the state calls render() again --> INFINITE LOOP\r\n  //   thisWillCrash = () => {\r\n  //     this.setState({\r\n  //       reservations: [],\r\n  //     })\r\n  //   }\r\n\r\n  // render() is a lifecycle method!\r\n  // render() is in charge of outputting the JSX from the component\r\n  // render() is invoked when the component mounts, and it's invoked AGAIN\r\n  // every time there's a change in the STATE of the component or the PROPS\r\n  // the component is receiving\r\n  // this.fetchReservations()\r\n  // PLEASE, DON'T SET YOUR STATE FROM RENDER()!\r\n  // this.thisWillCrash()\r\n\r\n  console.log(\"RENDER FIRED!\")\r\n\r\n  return (\r\n    <div>\r\n      <Container>\r\n        <Row>\r\n          <Col>\r\n            <h2>RESERVATIONS LIST</h2>\r\n            {/* we should find a way to hide the spinner once the loading process\r\n        has finished... */}\r\n\r\n            {/* LET'S CREATE A CONDITIONAL RENDERING FOR THE SPINNER */}\r\n            {/* && is called a SHORT CIRCUIT operator */}\r\n            {isLoading && (\r\n              <Spinner\r\n                animation=\"border\"\r\n                role=\"status\"\r\n                className=\"custom-spinner-color\"\r\n              >\r\n                <span className=\"sr-only\">Loading...</span>\r\n              </Spinner>\r\n              //   JSX IS ALWAYS A TRUTHY VALUE, SO WHAT YOU'RE REALLY CHECKING\r\n              // IS THE TRUTHINESS OF YOUR CONDITION\r\n            )}\r\n            <ListGroup className=\"mt-4\">\r\n              {/* <ListGroup.Item>Hello World!</ListGroup.Item> */}\r\n              {/* Let's create the connection between the interface and the state! */}\r\n              {/* In this way, for updating the list we won't have to manipulate the DOM, */}\r\n              {/* we'll just have to keep the state up-to-date */}\r\n              {reservations.map((r) => (\r\n                <ListGroup.Item key={r._id}>\r\n                  {r.name} for {r.numberOfPeople} |{\" \"}\r\n                  {format(parseISO(r.dateTime), \"MMMM do yyyy - HH:mm\")}\r\n                </ListGroup.Item>\r\n                // we'd like to convert r.dateTime, which is an ugly timestamp,\r\n                // to a proper formatted date. We're going to use 2 methods from date-fns:\r\n                // 1) parseISO takes the ugly timestamp and creates a Date object for it,\r\n                // pointing to a moment in time\r\n                // 2) format instead takes a Date object, and returns a string in the\r\n                // format you like\r\n              ))}\r\n              {isError && (\r\n                <Alert variant=\"danger\">\r\n                  Whoopsie, something went wrong! :(\r\n                </Alert>\r\n              )}\r\n            </ListGroup>\r\n          </Col>\r\n        </Row>\r\n      </Container>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default ReservationList\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}